C++ INFOSV Project - Questions

Q1.1: Simplement en utilisant les méthodes isColliding and isPointInside dans
le corps de ces méthodes de surcharge d'opérateurs.

Q1.2: Une surcharge interne car les deux opérateurs d'appliquent sur un objet de
type obstacle (comme une méthode le ferait).

Q1.3: L'argument de type colorAllele dans notre méthode colorToString pour
afficher la couleur d'un Genome, car nous ne voulons pas que la couleur puisse
être modifiée dans la méthode.
L'argument Genome passé à l'opérateur surchargé << pour la même raison.

Q1.4: Absolument toutes les méthodes internes à la classe, à l'exception du
constructeur. Car l'objet sur lequel est appellé un getter ou une méthode pour
l'afficher ne doit en aucun cas être modifié.

Q2.1: Uniquement la méthode drawOn, car toutes les autres modifient l'état de
l'objet Environment.

Q2.2: On aurait également pu détruire le constructeur de copies par défault avec
un 'delete' explicite.

Q2.3: La destruction d'un Environment devra donc induire la destruction de tous
la faune et les ressources y vivant.

Q2.4: "Vec2d attractionForce() const" Pour calculer la force d'attraction, elle
ne modifie pas l'objet en question et necessite de connaitre plusieurs attributs
du SeekingAutomaton. "void update(sf::Time dt)" La méthode update est faite pour
modifier les attributs de l'automaton en fonction du temps.

Q2.5: En créant l'enum Deceleration qui peut prendre les valeurs WEAK, MIDRANGE
ou STRONG. La décéleration est calculée en fonction de la distance. Pour moi
l'utilisation d'un type énuméré ici est redondante. Une simple méthode retournant
le coefficiant de décélération en rapport à la distance me semble plus clair.

Q2.6: ?? N'existe pas ?

Q2.7: Ajouter l'appel à la methode drawOn de l'animal pour tous les animaux de
l'environnement dans la méthode du dessin de ce dernier.

Q2.8:

Q2.9: Une liste de Vec2d repertoriant les positions des cibles vu par l'animal.

Q2.10: Appeler la méthode update pour chaque animal de l'Environment dans la
méthode update de l'Environment.

Q3.1: Toutes les méthodes peuvent être virtuelles pures car elle n'ont pas de
sens pour la classe abstraite Animal. Le mot override est à utiliser partout
pour ces méthodes dans Sheep et Wolf car elles redéfinissent celle de la classe
de base.

Q3.2: Il faut modifier les valeurs associées à l'objet en question. Il suffit
ensuite de presser sur la touche 'L' pour que l'Application le relise.

Q3.3: La méthode update.

Q3.4:

Q3.5: Au niveau de la classe LivingEntity car toutes les entitées peuvent hériter
de celle-ci et avoir un message de debuging.

Q3.6: Ecrire la méthode isDead() dans la classe LivingEntity avec les valeurs par
défaut, puis override cette méthode où nécessaire.

Q3.7: Appeler la méthode sur chaque entitée dans la classe Environment et les
retirer de la liste si elle sont morte, puis les détruire.

Q3.8: Comme la méthode getStandardMaxSpeed varie si l'Animal est un mouton ou un
loup, il est plus simple de la modifier séparement dans chacune de ces classes.
Ce qui permet d'avoir un facteur de ralentissement différent, ainsi qu'un seuil
critique différent en fonction de l'animal.

Q3.9: Simplement retourner la position de la LivingEntity.

Q3.10: Supprimer la classe obstacle et intégrer ses méthodes dans la classe
LivingEntity.

Q3.11: Le "double dispatch" sera géré de la même façon qu'à chaque fois mais
uniquementpour les animaux car une plante n'aura jamais de "mate in sight" et
donc ne fera jamais de rencontre.

Q3.12: Avec une variable de classe propre à tous les animaux, initialisée au
début dans le constructeur propre à chaque type d'animaux, puis réinitialisée
à chanque 'meeting'.

Q3.13:

Q3.14: Avec une variable de classe propre à tous les animaux.
